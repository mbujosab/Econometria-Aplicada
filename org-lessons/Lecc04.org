#    -*- mode: org -*-

#+TITLE: Lección 4. ACF, PACF y densidad espectral de modelos MA
#+author: Marcos Bujosa
#+LANGUAGE: es
# +OPTIONS: toc:nil

# https://www.tigerdata.com/blog/how-to-work-with-time-series-in-python
# https://pyspectrum.readthedocs.io/en/latest/ref_param.html

# https://github.com/QuantEcon/quantecon-notebooks-python/blob/master/arma.ipynb
# https://github.com/QuantEcon/lecture-python-intro
# https://quantecon.org/quantecon-py/
# https://quantecon.org/

#+include: 00preambulo_lecciones.txt


#+begin_src emacs-lisp :results silent :exports none
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((latex . t)))
#+end_src


#+BEGIN_SRC emacs-lisp :exports none :results silent
(use-package ox-ipynb
  :load-path (lambda () (expand-file-name "ox-ipynb" scimax-dir)))
(use-package htmlize)
#+END_SRC

#+LATEX: \maketitle

#+begin_abstract
Veremos tres funciones que caracterizan los momentos de segundo orden en procesos lineales: la función de autocorrelación (ACF), la función de autocorrelación parcial (PACF) y la densidad espectral. Las tres son transformaciones de la función de autocovarianzas. Primero, exploraremos estas funciones en procesos de ruido blanco y luego en procesos de media móvil (MA). Los procesos MA caracterizan series temporales con "memoria muy corta". Estos procesos dependen de un número finito y generalmente pequeño de innovaciones pasadas. A diferencia de los modelos autorregresivos, los procesos MA solo están correlados con unos pocos valores anteriores, lo que hace que su función de autocorrelación simple muestre pocas autocorrelaciones distintas de cero.
#+end_abstract

- ([[https://mbujosab.github.io/Econometria-Aplicada/Transparencias/Lecc04.slides.html][slides]]) --- ([[https://mbujosab.github.io/Econometria-Aplicada/Lecciones-html/Lecc04.html][html]]) --- ([[https://mbujosab.github.io/Econometria-Aplicada/Lecciones-pdf/Lecc04.pdf][pdf]]) --- ([[https://mybinder.org/v2/gh/mbujosab/Econometria-Aplicada/gh-pages?labpath=CuadernosElectronicos/Lecc04.ipynb][mybinder]])
  + programas análisis modelos arma: ([[https://mbujosab.github.io/Econometria-Aplicada/Transparencias/analisis_armas.slides.html][slides]]) --- ([[https://mbujosab.github.io/Econometria-Aplicada/Lecciones-html/src/analisis_armas.html][html]]) --- ([[https://mybinder.org/v2/gh/mbujosab/Econometria-Aplicada/gh-pages?labpath=CuadernosElectronicos/analisis_armas.ipynb][mybinder]]) 


#+begin_export html
<style>
.reveal  td {font-size: 60%;}
</style>
#+end_export

***** COMMENT para Jupyter-Notebook                               :noexport:
\(
\newcommand{\lag}{\mathsf{B}}
\newcommand{\Sec}[1]{\boldsymbol{#1}}
\newcommand{\Pol}[1]{\boldsymbol{#1}}
\)


***  Carga de algunos módulos de python y creación de directorios auxiliares
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . skip)))
   :UNNUMBERED: notoc
   :END:

   
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results none
# Para trabajar con los datos y dibujarlos necesitamos cargar algunos módulos de python
import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import matplotlib as mpl
# definimos parámetros para mejorar los gráficos
mpl.rc('text', usetex=False)
import matplotlib.pyplot as plt   # data visualization
import dataframe_image as dfi   # export tables as .png
#+END_SRC

**** Directorio auxiliar para albergar las figuras de la lección:
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . skip)))
   :UNNUMBERED: t 
   :END:

#+attr_ipynb: (slideshow . ((slide_type . skip)))
para publicar la lección como pdf o página web, necesito los gráficos como ficheros ~.png~ alojados algún directorio específico:
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results silent
imagenes_leccion = "./img/lecc04" # directorio para las imágenes de la lección
import os
os.makedirs(imagenes_leccion, exist_ok=True) # crea el directorio si no existe
#+END_SRC


*** Gráficos para las ACF, PACF y densidades espectrales teóricas
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . skip)))
   :UNNUMBERED: notoc
   :END:

#+attr_ipynb: (slideshow . ((slide_type . skip)))
Cargamos las funciones auxiliares (véase la carpeta =src/=)

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results silent
%run -i ./src/analisis_armas.py
#+END_SRC

# import warnings
# warnings.filterwarnings("ignore", category=UserWarning)


#+latex: \newpage


* Funciones de autocovarianzas y de autocorrelación (ACF)
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . slide)))
   :END:

Si un proceso estocástico es estacionario, la covarianza entre $X_t$ y $X_{t+k}$ no depende de $t$; tan solo depende de la distancia temporal $k$ entre ambas variables aleatorias: $\;Cov(X_t,X_{t-k})=\gamma_k.\;$ 

- La secuencia $\boldsymbol{\gamma}=(\gamma_k\mid k\in\mathbb{Z})$ se denomina /función de
  autocovarianzas/
- Dividiendo $\boldsymbol{\gamma}$ por $\gamma_0$ obtenemos la
  secuencia $\boldsymbol{\rho}=(\rho_k\mid k\in\mathbb{Z})$ donde
  $$\rho_k=\frac{Cov(X_t,X_{t-k})}{\sqrt{Var(X_t)Var(X_{t-k})}}=\frac{\gamma_k}{\gamma_0},$$
  #+LATEX: \newline  \noindent
  que se denomina /función de autocorrelación/ (ACF).

#+attr_ipynb: (slideshow . ((slide_type . fragment)))
Veamos otras transformaciones de $\boldsymbol{\gamma}$ que subrayan
diferentes características de la interdependencia temporal en un
proceso estocástico.

#+LATEX: \newline  \noindent


* Función de autocorrelación parcial  (PACF)
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . slide)))
   :END:

#+BEGIN_EXPORT latex
Dado un conjunto de variables
$\boldsymbol{Z}=(Z_1,Z_2,\ldots Z_k)$, la \emph{correlación condicional} 
$\rho_{X,Y|\boldsymbol{Z}}$ entre las variables $X$ e $Y$ es
$$\rho_{X,Y|\boldsymbol{Z}}=Corr\Big(X-E(X\mid\boldsymbol{Z}),\ Y-E(Y\mid\boldsymbol{Z})\Big)$$ 
El problema es que no siempre es fácil conocer las esperanzas condicionadas 
$E(X\mid\boldsymbol{Z})$ y $E(Y\mid\boldsymbol{Z})$.

Pero es sencillo restar de $X$ y de $Y$ los ajustes $\widehat{X}$ y $\widehat{Y}$ 
correspondientes a sus respectivas regresiones lineales sobre $\boldsymbol{Z}$. 
La correlación entre ambos residuos se denomina \emph{correlación parcial} 
entre $X$ e $Y$; y mide la correlación entre ambas variables una vez  
``descontado'' el efecto lineal de las variables $\boldsymbol{Z}$.
$$Corr\Big((X-\widehat{X}),\ (Y-\widehat{Y})\Big)$$
#+END_EXPORT

La /correlación parcial/ entre dos variables $X_t$ y $X_{t-k}$ de un
proceso estacionario $\boldsymbol{X}$ mide su correlación una vez
descontado el efecto de las variables $X_{t-1},\ldots X_{t-(k-1)}$ que
median entre ambas.
$$X_t,\ \overbrace{X_{t-1},\ldots X_{t-(k-1)},}\ X_{t-k}$$

Si denotamos con $\widehat{X_t}$ y $\widetilde{X_{t-k}}$ los ajustes de
las respectivas regresiones de $X_t$ y $X_{t-k}$ sobre $X_{t-1},\ldots
X_{t-(k-1)};\;$ la /correlación parcial/ $\pi_k$ entre $X_t$ y $X_{t+k}$ es la
correlación entre los residuos de sendas regresiones:
$$\pi_k=Corr\Big((X_t-\widehat{X_t}),\ (X_{t-k}-\widetilde{X_{t-k}})\Big)$$

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
En un proceso débilmente estacionario las correlaciones parciales solo
dependen de la distancia $k$, lo que permite definir la siguiente
secuencia.
#+LATEX: \medskip

*La función de autocorrelación parcial* (PACF) de un proceso
estocástico estacionario $\boldsymbol{X}$ es la siguiente secuencia
$\boldsymbol{\pi}$ simétrica ($\pi_{-k}=\pi_k$):

$$\boldsymbol{\pi}=(\pi_k\mid k\in\mathbb{Z})=
\begin{cases} 
  \pi_0 & = \rho_0 ={\color{blue}{1}}\\\\ 
  \pi_1 &=Corr(X_t,\ X_{t-1})=\rho_1=\frac{\gamma_1}{\gamma_0}\\\\ 
  \pi_k &=Corr\Big((X_t-\widehat{X_t}),\ (X_{t-k}-\widetilde{X_{t-k}})\Big)
\end{cases},$$ 
donde $\widehat{X_t}$ y $\widetilde{X_{t-k}}$ son los ajustes de las
respectivas regresiones de $X_t$ y $X_{t-k}$ sobre $X_{t-1},\ldots
X_{t-(k-1)};\;$ i.e., las proyecciones ortogonales sobre
$\bar{sp}(1,X_{t-1},\ldots X_{t-(k-1)})$.
#+LATEX: \medskip

#+attr_ipynb: (slideshow . ((slide_type . fragment)))
La magnitud de la correlación parcial $\;\pi_k\;$ *refleja la mejora
en la predicción de $\widehat{X_t}$ si* en lugar de usar una
combinación lineal con solo los $k-1$ primeros retardos,
$\widehat{X_t}=\widehat{\alpha_0}+\sum_{j=1}^{k-1}\widehat{\alpha_j}
X_{t-j}$, *empleamos $k$ retardos* (i.e., un retardo más).
#+LATEX: \medskip

Así, la PACF nos ayudará a identificar el orden de procesos autoregresivos.
#+LATEX: \medskip

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
Hay una correspondencia uno-a-uno entre la función de autocovarianzas
$\boldsymbol{\gamma}$ y la PACF $\boldsymbol{\pi}$. 

Es decir, es posible reconstruir una de las secuencias a partir de la
otra (por ejemplo resolviendo las [[file:./Lecc05.html#org392fab2][ecuaciones de Yule-Walker]]
recursivamente con el algoritmo [[https://en.wikipedia.org/wiki/Levinson_recursion][Levinson-Durbin]]; véase
/Pourahmadi, M. (2001, Capítulo 7)/ o /Brockwell & Davis (1991,
Capítulo 5)/)

*************** TODO COMMENT Incluir algoritmo en los apuntes      :@EctrApl:

# \(\pi_1=\phi_{11}=\rho_1\)

# \(\pi_{k+1}=\phi_{k+1,k+1}=\frac{\rho_{k+1}-\sum_{j=1}^k\phi_{kj}\rho_{k+1-j}}{1-\sum_{j=1}^k\phi_{kj}\rho_j}\); donde $\phi_{k+1,j}=\phi_{kj}-\phi_{k+1,k+1}\phi_{k,k+1-j}$, $j=1:k$

Así, la PACF $\boldsymbol{\pi}$ puede verse como una reparametrización de la función de autocovarianzas $\boldsymbol{\gamma}$.

Veamos otra transformación de $\boldsymbol{\gamma}$ que también
arrojará luz sobre las propiedades de un proceso estocástico.


* Densidad espectral
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . slide)))
   :END:

Si $\boldsymbol{X}$ es un proceso estocástico con función de
autocovarianzas $\boldsymbol{\gamma}\in\ell^1$, es decir, con función
de autocovarianzas absolutamente sumable,
$$\sum_{k\in\mathbb{Z}}|\gamma_k|<\infty,$$ entonces definimos la
/densidad espectral/ de $\boldsymbol{X}$ como $$f(\omega)
\quad=\quad\frac{1}{2\pi}\sum_{k\in\mathbb{Z}}\gamma_k e^{-i k\omega}
\quad=\quad{\color{blue}{\frac{1}{2\pi}\sum_{k\geq0}\gamma_k \cos(k\omega)}},\qquad
\omega\in[-\pi,\pi],$$
(donde $w$ son las frecuencias de oscilación de la serie).
#+LATEX: \medskip

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
La /densidad espectral/ $f(\omega)$ satisface las siguientes
propiedades:
a) $f(\omega)=f(-\omega)$
b) $f(\omega)\geq0$
c) $\int_{-\pi}^\pi f(\omega)d\omega<\infty$

#+attr_ipynb: (slideshow . ((slide_type . fragment)))
Es más, partiendo de la densidad espectral se pueden calcular las
covarianzas $$\gamma_k=\int_{-\pi}^\pi f(\omega)e^{-i
k\omega}d\omega;\quad k\in\mathbb{Z}$$

#+attr_ipynb: (slideshow . ((slide_type . fragment)))
Consecuentemente, para $k=0$
$$\sigma^2=\gamma_0=\int_{-\pi}^\pi f(\omega)d\omega.$$

Por tanto podemos interpretar la densidad espectral como una
descomposición de la varianza en sumas de oscilaciones con distintas frecuencias (o periodos).
#+LATEX: \medskip

#+attr_ipynb: (slideshow . ((slide_type . fragment)))
#+LATEX: \noindent
($Periodo=\frac{1}{Frecuencia}$, donde la Frecuencia = Ciclos por unidad de tiempo).

#+attr_ipynb: (slideshow . ((slide_type . slide)))
- La ACF, la PACF y la /densidad espectral/ son funciones que dependen únicamente de los segundos momentos de la distribución.

- Su estimación y posterior análisis son la herramienta fundamental para elegir un modelo ARMA para una serie temporal /``estacionaria''/.

- Para entenderlo debemos ver cómo son estas funciones en algunos modelos lineales concretos.

#+attr_ipynb: (slideshow . ((slide_type . skip)))
Comenzaremos por los /procesos lineales causales/ genéricos; de los cuales se derivan los modelos estacionarios que veremos en el curso. Hoy los procesos de ruido blanco y los procesos de medias móviles MA($q$).

En la lección próxima: los procesos autorregresivos AR($p$) y los procesos ARMA($p,q$).

* ACF, PACF y densidad espectral de algunos modelos lineales
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . skip)))
   :END:


#+attr_ipynb: (slideshow . ((slide_type . skip)))
Comencemos con el caso general:

** Procesos lineales causales
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . slide)))
   :END:


Sea $\;\boldsymbol{X}=\boldsymbol{\psi}*\boldsymbol{U},\;$
donde $\;\boldsymbol{U}\sim WN(0,\sigma^2)\;$ y
$\;\boldsymbol{\psi}\in\ell^2\;$ es una serie formal:
$$X_t=\sum_{j\geq0}\psi_j U_{t-j}.$$ Por la [[https://mbujosab.github.io/Econometria-Aplicada/Lecciones-pdf/Lecc03.pdf#subsection.4.2][lección anterior]] sabemos
que $\;E(X_t)=0\;$ y que
- $\boldsymbol{\gamma} \;=\; \sigma^2 \boldsymbol{\psi}(z)*\boldsymbol{\psi}(z^{-1})$
#+attr_ipynb: (slideshow . ((slide_type . notes)))
  Es decir, 
  $$\gamma_k = \sigma^2\sum_{j=0}^\infty \psi_{j+|k|}\cdot\psi_j.$$ 
  Y como $\;\boldsymbol{\psi}\;$ es serie formal de cuadrado sumable, $\;\gamma_k\to0\;$ cuando $\;k\to\infty$
#+BEGIN_EXPORT latex
\medskip

\emph{Demostración}:  aplicando la desigualdad de Cauchy-Schwarz
\begin{displaymath}
|\gamma_k| \; \leq  \; \sigma^2 
\left(\sum_{j=0}^\infty |\psi_{j+k}|^2\right)^{\frac{1}{2}}
\left(\sum_{j=0}^\infty |\psi_{j}|^2\right)^{\frac{1}{2}}
% \\ &
\; = \;
\sigma^2 
\left(\sum_{j=k}^\infty |\psi_{j}|^2\right)^{\frac{1}{2}}
\left(\sum_{j=0}^\infty |\psi_{j}|^2\right)^{\frac{1}{2}} 
\end{displaymath}
y puesto que $\boldsymbol{\psi}$ es de cuadrado sumable, la cola 
$\sum_{j=k}^\infty |\psi_{j}|^2$ 
converje a cero cuando $k\to\infty$.
\bigskip

Fíjese que en particular, 
$$\gamma_0 = Var(X_t) = \sigma^2\sum_{j=0}^\infty \psi_j^2;$$
donde la suma es convergente dado que $\boldsymbol{\psi}$ es de cuadrado sumable.
\medskip

#+END_EXPORT

#+attr_ipynb: (slideshow . ((slide_type . fragment)))
A partir de $\boldsymbol{\gamma}$ obtenemos las otras tres funciones:

*ACF*: $\;\boldsymbol{\rho} \;=\; \frac{1}{\gamma_0}\boldsymbol{\gamma}$

*Dens. espectral*:  \(\;f(\omega)=\frac{1}{2\pi}\sum_{k\geq0}\gamma_k\cos(k\omega)\)@@latex:;\quad\omega\in[-\pi,\pi]@@

*PACF*: $\;\boldsymbol{\pi}\in\ell^2,\quad$ i.e., $\;\pi_k\to0\;$ cuando $\;k\to\infty$ 

#+BEGIN_EXPORT latex
\noindent
(Cuando $\boldsymbol{\pi}\in\ell^2$ se dice que el proceso es \emph{no-determinista}.)
#+END_EXPORT


** Proceso de Ruido Blanco
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . slide)))
   :END:

Sea $\boldsymbol{X}=1*\boldsymbol{U}$,
donde $\;\boldsymbol{U}\sim WN(0,\sigma^2)\;;$ es decir $X_t=U_t$ para
$t\in\mathbb{Z}$. Entonces

- $\boldsymbol{\gamma} \;=\; \sigma^2 (1z^0*1z^{0}) \;=\; \sigma^2z^0 \;=\; (\ldots,0,0,{\color{blue}{\sigma^2}},0,0,\ldots)$

# - $\boldsymbol{\gamma} \;=\; \sum_{k\in\mathbb{Z}}\gamma_k z^k \;=\; \sigma^2 z^0 \;=\; \sigma^2\boldsymbol{1} \;=\; (\ldots,0,0,\sigma^2,0,0,\ldots)$

- $\boldsymbol{\rho} \;=\; \frac{1}{\gamma_0}\boldsymbol{\gamma} \;=\;
  \frac{1}{\sigma^2}\boldsymbol{\gamma} \;=\; 1 z^0 \;=\;
  (\ldots,0,0,{\color{blue}{1}},0,0,\ldots)$

# - $\boldsymbol{\rho} \;=\; \sum_{k\in\mathbb{Z}}\frac{\gamma_k}{\gamma_0} z^k \;=\; 1 z^0 \;=\; \boldsymbol{1} \;=\; (\ldots,0,0,1,0,0,\ldots)$

- $f(\omega) \;=\; \frac{1}{2\pi}\sum_{k\geq0}\gamma_k \cos(k\omega) \;=\; \frac{\sigma^2}{2\pi} \cos(0\omega) \;=\; \frac{\sigma^2}{2\pi};\quad \omega\in[-\pi,\pi]$

- $\boldsymbol{\pi} \;=\; 1 z^0 \;=\; (\ldots,0,0,{\color{blue}{1}},0,0,\ldots)$


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACFwhitenoise.png :exports code :results none
ar_params = [1,]
ma_params = [1,]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, 1, lags=20)
fig.savefig('./img/lecc04/ACFwhitenoise.png', dpi=300, bbox_inches='tight')
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACFwhitenoise.png]]

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file SimulWhitenoise.png :exports code :results none
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/SimulWhitenoise.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_ipynb: (slideshow . ((slide_type . fragment)))
#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/SimulWhitenoise.png]]


#+attr_ipynb: (slideshow . ((slide_type . fragment)))
[[./img/lecc04/colores.png]]

#+attr_ipynb: (slideshow . ((slide_type . notes)))
Los procesos de ruido blanco son los más simples. Carecen de correlación serial, lo que significa que el valor tomado en un momento determinado no aporta información útil para predecir valores futuros.
Si los residuos de un modelo ajustado a una serie temporal no son /ruido blanco/, significa que queda correlación serial no captada por el modelo, por lo que dicho modelo es mejorable.

El nombre de /ruido blanco/ se debe a que su función de densidad espectral es constante, indicando que, al descomponer la varianza en sumas de oscilaciones de diferentes frecuencias, todas las frecuencias tienen la misma relevancia o intensidad. Esta es una circunstancia análoga al fenómeno físico de la luz blanca, que contiene todos los colores (oscilaciones de la onda electromagnética en cada frecuencia) con idéntica intensidad. Al observar la luz /blanca/, percibimos todas esas oscilaciones simultáneamente, lo que nos da la percepción de color /blanco/. Sin embargo, al pasarla por un prisma, podemos descomponerla y ver los colores por separado (/la densidad espectral es como un prisma, pues nos deja ver la intensidad de las distintas oscilaciones por separado/).

#+BEGIN_SRC jupyter-python :exports none :results silent
from PIL import Image, ImageDraw

# Colores del arcoíris (hexadecimales)
colores = [
    "#e81416",  # Rojo
    "#ffa500",  # Naranja
    "#faeb36",  # Amarillo
    "#21FF67",  # Verde
    "#21F8FF",  # Azul
    "#2172FF",  # Índigo
    "#7621FF",  # Violeta
]

# Función para interpolar entre dos colores
def interpolar_color(color1, color2, t):
    c1 = tuple(int(color1[i:i+2], 16) for i in (1, 3, 5))
    c2 = tuple(int(color2[i:i+2], 16) for i in (1, 3, 5))
    return "#{:02x}{:02x}{:02x}".format(
        int(c1[0] + (c2[0] - c1[0]) * t),
        int(c1[1] + (c2[1] - c1[1]) * t),
        int(c1[2] + (c2[2] - c1[2]) * t),
    )

# Dimensiones de la imagen
ancho = 700  # Ancho total de la imagen
alto = 30    # Altura de la imagen

# Crear una nueva imagen
imagen = Image.new("RGB", (ancho, alto))

# Crear un objeto de dibujo
draw = ImageDraw.Draw(imagen)

# Dibujar el degradado
num_colores = len(colores) - 1
for x in range(ancho):
    # Determinar en qué segmento de colores estamos
    segmento = x / (ancho / num_colores)
    i = int(segmento)  # Índice del color inicial
    t = segmento - i   # Proporción entre el color inicial y el siguiente
    color = interpolar_color(colores[i], colores[i + 1], t)
    draw.line([(x, 0), (x, alto)], fill=color)

# Guardar la imagen
imagen.save("./img/lecc04/colores.png", dpi=(300, 300))
#+END_SRC

** Proceso de media móvil MA($q$)
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . slide)))
   :END:

Sea $\boldsymbol{X}=\boldsymbol{\theta}*\boldsymbol{U}$, con $\;\boldsymbol{U}\sim WN(0,\sigma^2)\;$ y donde $\boldsymbol{\theta}$ es un polinomio de orden $q>0$, con $\theta_0=1$ y con todas sus raíces fuera del círculo unidad $(\boldsymbol{\theta}^{-\triangleright}\in\ell^1)$:
$$X_t=\sum_{j=1}^q\theta_j U_{t-j}+U_t.$$

#+BEGIN_EXPORT latex
\begin{quotation}
\em
El requisito sobre las raíces no es necesario para que el proceso sea estacionario, pero por conveniencia se usan modelos MA que tengan representación AR($\infty$) \emph{causal}:
$$\boldsymbol{X}=\boldsymbol{\theta}*\boldsymbol{U}
\quad\rightarrow\quad
\frac{1}{\boldsymbol{\theta}}*\boldsymbol{X}=\boldsymbol{U}
\quad\Rightarrow\quad
U_t = \sum_{j=0}^\infty\psi_j X_{t-j}
$$
donde $\boldsymbol{\psi}=\boldsymbol{\theta}^{-\triangleright}=\boldsymbol{\theta}^{-1}\in\ell^1$. Entonces se dice que el modelo MA es ``\emph{invertible}''. 
\medskip

Cualquier modelo MA sin raíces en el círculo unitario puede reparametrizarse en un nuevo modelo con idéntica función de autocovarianzas $\boldsymbol{\gamma}$ (\emph{véase la Sección 2.6 de Fuller (1996)}). Por tanto, el nuevo modelo exhibirá las mismas ACF, PACF y densidad espectral que el modelo original.
Para garantizarnos una correspondencia uno a uno entre ACFs y procesos estocásticos, siempre asumiremos que las raíces del polinomio $\boldsymbol{\theta}$ son mayores que uno en valor absoluto.
\end{quotation}
#+END_EXPORT

Entonces $\;E(X_t)=0\;$ y

$\boldsymbol{\gamma}=\; \sigma^2 \boldsymbol{\theta}(z)*\boldsymbol{\theta}(z^{-1}) \;=\; \sigma^2 \sum\limits_{j=0}^q \theta_{j+k}\theta_{j} z^{k}$ (grado $q$; cogrado $-q$) ([[https://mbujosab.github.io/Econometria-Aplicada/Lecciones-pdf/Lecc02.pdf#subsection.9.3][Lecc. 02]])

$\boldsymbol{\rho}=\; \frac{1}{\gamma_0}\boldsymbol{\gamma}$

$f(\omega)=\; \frac{\sigma^2}{2\pi}\boldsymbol{\theta}(e^{-i\omega})\cdot\boldsymbol{\theta}(e^{i\omega}) \;=\; \frac{1}{2\pi}\sum\limits_{h=0}^q \gamma_h \cos(h\omega);\quad \omega\in[-\pi,\pi]$ ($q$ cosenos $+1$)

$\boldsymbol{\pi}\;$ con grado $\infty$ y cogrado $-\infty$. Su magnitud decae paulatinamente cuando $\;k\to\infty$

#+attr_ipynb: (slideshow . ((slide_type . subslide)))

#+latex: \noindent
Un proceso MA es _siempre estacionario._
#+latex: \bigskip

*Tipos de representación del proceso*

#+latex: \noindent
- Como suma ponderada finita :: MA($q$) (número finito de parámetros)
  $$\boldsymbol{X}=\boldsymbol{\theta}*\boldsymbol{U}
  \quad\Rightarrow\quad X_t=\boldsymbol{\theta}(\mathsf{B})U_t$$
- Como suma ponderada infinita :: AR($\infty$) (_solo existe si es invertible_):
  $$\frac{1}{\boldsymbol{\theta}}*\boldsymbol{X}=\boldsymbol{U}
  \quad\Rightarrow\quad
  \frac{1}{\boldsymbol{\theta}}(\mathsf{B})X_t=U_t$$
#+latex: \bigskip

#+latex: \noindent
Para ser invertible raíces $\boldsymbol{\theta}$ fuera del círculo
unidad
$(\boldsymbol{\theta}^{-\triangleright}=\boldsymbol{\theta}^{-1}\in\ell^1)$

Los procesos MA se caracterizan por su ``memoria muy corta''. Estos procesos dependen de un número finito, generalmente pequeño, de innovaciones pasadas. 

A diferencia de los modelos autorregresivos, los procesos MA solo presentan correlación con un número limitado de valores anteriores, lo que permite que su función de autocorrelación simple tenga solo unas pocas autocorrelaciones diferentes de cero.

** Proceso de media móvil MA($1$)
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . slide)))
   :END:

Sea $\boldsymbol{X}=(1-\theta z)*\boldsymbol{U}$ con $|\theta|<1$ y
con $\;\boldsymbol{U}\sim WN(0,\sigma^2)\;$, es decir $$X_t=U_t-\theta
U_{t-1}.$$

- $\boldsymbol{\gamma} \;=\; \sigma^2 (1-\theta z)*(1-\theta z^{-1})
  \;=\; \sigma^2 (\ldots,\ 0\ ,\ -\theta,\
  {\color{blue}{(1+\theta^2)}},\ -\theta,\ 0,\ \ldots)$

- $\boldsymbol{\rho} \;=\; \frac{1}{\gamma_0}\boldsymbol{\gamma} \;=\;
  \frac{1}{\sigma^2(1+\theta^2)}\boldsymbol{\gamma}\;=\; (\ldots,\ 0\
  ,\ \frac{-\theta}{1+\theta^2},\ {\color{blue}{1}},\
  \frac{-\theta}{1+\theta^2},\ 0,\ \ldots)$

- $f(\omega) \;=\;
  \frac{\sigma^2}{2\pi}\boldsymbol{\theta}(e^{-i\omega})\cdot\boldsymbol{\theta}(e^{i\omega})
  \;=\;
  \frac{\sigma^2}{2\pi}\Big((1+\theta^2)\;-\;2\theta\cos(\omega)\Big);\quad
  \omega\in[-\pi,\pi]$

- $\boldsymbol{\pi} \;=\; \sum\limits_{k\in\mathbb{Z}}{  \frac{-\theta^k(1-\theta^2)}{1-\theta^{2(k+1)}} z^k}$

*** MA(1) con raíz positiva
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . notes)))
   :END:

# PARÁMETRO NEGATIVO (violeta)


#+attr_ipynb: (slideshow . ((slide_type . subslide)))
$$\boldsymbol{\theta}(z)=1-0.9z\quad\Rightarrow\quad X_t=
(1-0.9 \mathsf{B})U_t\qquad {\color{blue}{(\theta>0)}}$$


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACF-MA1p.png :exports code :results silent
ar_params = [1,]
ma_params = [1, -0.9]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, sigma2=1, lags=20)
fig.savefig('./img/lecc04/ACF-MA1p.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACF-MA1p.png]]


#+name: raices-ma1p
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Roots-MA1p.png :results silent :exports results
dfi.export(polynomial_roots_table(ma_params),
           "./img/lecc04/Roots-MA1p.png", dpi=300, table_conversion="matplotlib")
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+attr_html: :width 500px
#+attr_org: :width 800
#+attr_latex: :width 250px
[[file:img/lecc04/Roots-MA1p.png]]



#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Sim-MA1p.png :exports code :results silent
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/Sim-MA1p.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_ipynb: (slideshow . ((slide_type . fragment)))
#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/Sim-MA1p.png]]

*** MA(1) con raíz negativa
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . notes)))
   :END:

# PARÁMETRO POSITIVO (rojo)

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
$$\boldsymbol{\theta}(z)=1+0.9z\quad\Rightarrow\quad X_t=
(1+0.9 \mathsf{B})U_t\qquad {\color{blue}{(\theta<0)}}$$


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACF-MA1n.png :exports code :results silent
ar_params = [1,]
ma_params = [1, 0.9]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, sigma2=1, lags=20)
fig.savefig('./img/lecc04/ACF-MA1n.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACF-MA1n.png]]

#+name: raices-ma1n
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Roots-MA1n.png :results silent :exports results
dfi.export(polynomial_roots_table(ma_params),
           "./img/lecc04/Roots-MA1n.png", dpi=300, table_conversion="matplotlib")
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+attr_html: :width 500px
#+attr_org: :width 800
#+attr_latex: :width 250px
[[file:img/lecc04/Roots-MA1n.png]]



#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Sim-MA1n.png :exports code :results silent
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/Sim-MA1n.png', dpi=300, bbox_inches='tight')
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . fragment)))
#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/Sim-MA1n.png]]


** Proceso de media móvil MA($2$)
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . slide)))
   :END:

Sea $\boldsymbol{X}=(1-\theta_1 z-\theta_2 z^2)*\boldsymbol{U}$, con
$\;\boldsymbol{U}\sim WN(0,\sigma^2)\;$ y con
$$\theta_1+\theta_2<1;\qquad \theta_2-\theta_1<1;\qquad |\theta_2|<1;\quad \text{(i.e., invertible)}$$
es decir $X_t=U_t-\theta_1 U_{t-1}-\theta_2 U_{t-2}$.

- $\boldsymbol{\gamma} \;=\; \sigma^2 (1-\theta_1 z-\theta_2 z^2)*(1-\theta_1 z^{-1}-\theta_2 z^{-2})$
  # $\sigma^2(\ldots,\; 0,\; -\theta_2,\; -\theta_1(1-\theta_2),\; {\color{blue}{1+\theta_1^2+\theta_2^2}},\; -\theta_1(1-\theta_2),\; -\theta_2,\; 0,\;\ldots)$ 
  
  $\gamma_0={\color{blue}{\sigma^2(1+\theta_1^2+\theta_2^2)}};\qquad$
  $\gamma_1=\sigma^2\big(-\theta_1(1-\theta_2)\big);\qquad$
  $\gamma_2=\sigma^2(-\theta_2)$

  $\gamma_3=\gamma_4=\cdots=0\qquad$ (y es simétrica) 

- $\boldsymbol{\rho} \;=\; \frac{1}{\gamma_0}\boldsymbol{\gamma} \;=\; \frac{1}{\sigma^2(1+\theta_1^2+\theta_2^2)}\boldsymbol{\gamma}$

- $f(\omega) \;=\;  \frac{\sigma^2}{2\pi}\Big((1+\theta_1^2+\theta_2^2)\;-\;2\theta_1(1+\theta_2)\cos(\omega)\;-\;2\theta_2\cos(2\omega)\Big)$
# ;\; -\pi\leq\omega\leq\pi
# \frac{\sigma^2}{2\pi}\boldsymbol{\theta}(e^{-i\omega})*\boldsymbol{\theta}(e^{i\omega}) \;=\;

- $\boldsymbol{\pi}$ tiene una expresión complicada, pero su magnitud
  decae paulatinamente.

#+attr_ipynb: (slideshow . ((slide_type . subslide)))

#+CAPTION: El interior del triángulo es la región paramétrica donde un MA(2) es invertible. Por debajo de la parábola las raíces son complejas. El signo del parámetro $\theta_1$ determina el signo del primer retardo de la ACF y $\theta_2$ el signo del segundo. Las regiones 1, 2, 3, y 4 determinan cómo decae la PACF. Las cuatro subsecciones sobre modelos MA(2) muestran, por orden, ejemplos de estas 4 regiones.
#+attr_org: :width 400
#+attr_html: :width 600px
#+attr_latex: :width 300px
[[file:img/lecc04/MA2roots.png]]

# #+BEGIN_SRC python :exports results
# exec(open('./src/analisis_armas.py').read())
# RegionParametrica('MA').savefig('./img/lecc04/MA2roots.png', dpi=300, bbox_inches='tight')
# #+END_SRC

#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file MA2roots.png :exports none :results silent
RegionParametrica('MA').savefig('./img/lecc04/MA2roots.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+RESULTS:

*** MA(2) con dos parámetros positivos ($+$, $+$)
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . notes)))
   :END:
# $\theta_1>0$ y $\theta_2>0$

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
\[
\boldsymbol{\theta}(z) = 1-0.6z -0.3z^2
\quad\Rightarrow\quad 
X_t=(1-0.6\mathsf{B}-0.3\mathsf{B}^2)U_t
;\;\; 
{\color{blue}{(\theta_1>0 \;\text{y}\; \theta_2>0)}}
\]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACF-MA2thpp.png :exports code :results silent
ar_params = [1,]
ma_params = [1, -0.6, -0.3]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, sigma2=1, lags=20)
fig.savefig('./img/lecc04/ACF-MA2thpp.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACF-MA2thpp.png]]


#+name: raices-ma2thpp
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Roots-MA2thpp.png :results silent :exports results
dfi.export(polynomial_roots_table(ma_params),
           "./img/lecc04/Roots-MA2thpp.png", dpi=300, table_conversion="matplotlib")
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+attr_html: :width 500px
#+attr_org: :width 800
#+attr_latex: :width 250px
[[file:img/lecc04/Roots-MA2thpp.png]]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Sim-MA2thpp.png :results none
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/Sim-MA2thpp.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_ipynb: (slideshow . ((slide_type . fragment)))
#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/Sim-MA2thpp.png]]

*** MA(2) con parámetros de distinto signo ($-$, $+$)
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . notes)))
   :END:

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
\[
\boldsymbol{\theta}(z)=1+0.6z -0.3z^2
\quad\Rightarrow\quad 
X_t=(1+0.6\mathsf{B}-0.3\mathsf{B}^2)U_t
\;\; {\color{blue}{(\theta_1<0 \;\text{y}\; \theta_2>0)}}
\]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACF-MA2thnp.png :exports code :results silent
ar_params = [1,]
ma_params = [1, +0.6, -0.3]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, sigma2=1, lags=20)
fig.savefig('./img/lecc04/ACF-MA2thnp.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACF-MA2thnp.png]]


#+name: raices-ma2thnp
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Roots-MA2thnp.png :results silent :exports results
dfi.export(polynomial_roots_table(ma_params),
           "./img/lecc04/Roots-MA2thnp.png", dpi=300, table_conversion="matplotlib")
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+attr_html: :width 500px
#+attr_org: :width 800
#+attr_latex: :width 250px
[[file:img/lecc04/Roots-MA2thnp.png]]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Sim-MA2thnp.png :results none
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/Sim-MA2thnp.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_ipynb: (slideshow . ((slide_type . fragment)))
#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/Sim-MA2thnp.png]]

*** MA(2) con dos parámetros negativos ($-$, $-$)
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . notes)))
   :END:
# $\theta_1>0$ y $\theta_2>0$

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
\[
\boldsymbol{\theta}(z) = 1+0.9z +0.9z^2
\quad\Rightarrow\quad 
X_t=(1+0.9\mathsf{B}+0.9\mathsf{B}^2)U_t
;\;\; 
{\color{blue}{(\theta_1<0 \;\text{y}\; \theta_2<0)}}
\]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACF-MA2thnn.png :exports code :results silent
ar_params = [1,]
ma_params = [1, +0.9, 0.9]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, sigma2=1, lags=20)
fig.savefig('./img/lecc04/ACF-MA2thnn.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACF-MA2thnn.png]]


#+name: raices-ma2thnn
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Roots-MA2thnn.png :results silent :exports results
dfi.export(polynomial_roots_table(ma_params),
           "./img/lecc04/Roots-MA2thnn.png", dpi=300, table_conversion="matplotlib")
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+attr_html: :width 500px
#+attr_org: :width 800
#+attr_latex: :width 250px
[[file:img/lecc04/Roots-MA2thnn.png]]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Sim-MA2thnn.png :results none
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/Sim-MA2thnn.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_ipynb: (slideshow . ((slide_type . fragment)))
#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/Sim-MA2thnn.png]]

*** MA(2) con parámetros de distinto signo ($+$, $-$)
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . notes)))
   :END:

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
\[
\boldsymbol{\theta}(z)=1-1.1z +0.9z^2
\quad\Rightarrow\quad 
X_t=(1-1.1\mathsf{B}+0.9\mathsf{B}^2)U_t
\;\; {\color{blue}{(\theta_1>0 \;\text{y}\; \theta_2<0)}}
\]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACF-MA2thpn.png :exports code :results silent
ar_params = [1,]
ma_params = [1, -1.1, 0.9]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, sigma2=1, lags=20)
fig.savefig('./img/lecc04/ACF-MA2thpn.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACF-MA2thpn.png]]


#+name: raices-ma2thpn
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Roots-MA2thpn.png :results silent :exports results
dfi.export(polynomial_roots_table(ma_params),
           "./img/lecc04/Roots-MA2thpn.png", dpi=300, table_conversion="matplotlib")
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+attr_html: :width 500px
#+attr_org: :width 800
#+attr_latex: :width 250px
[[file:img/lecc04/Roots-MA2thpn.png]]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Sim-MA2thpn.png :results none
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/Sim-MA2thpn.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_ipynb: (slideshow . ((slide_type . fragment)))
#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/Sim-MA2thpn.png]]

*** MA(2) con dos raíces reales, una positiva y la otra negativa
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . notes)))
   :END:

# MA2 verde

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
\[
\boldsymbol{\theta}(z)=1-0.64z^2
\quad\Rightarrow\quad 
X_t=(1-0.64\mathsf{B}^2)U_t
\;\; {\color{blue}{(\text{raices reales: +, -})}}
\]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACF-MA2pn.png :exports code :results silent
ar_params = [1,]
ma_params = [1, 0, -0.64]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, sigma2=1, lags=20)
fig.savefig('./img/lecc04/ACF-MA2pn.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACF-MA2pn.png]]



#+name: raices-ma2pn
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Roots-MA2pn.png :results silent :exports results
dfi.export(polynomial_roots_table(ma_params),
           "./img/lecc04/Roots-MA2pn.png", dpi=300, table_conversion="matplotlib")
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+attr_html: :width 500px
#+attr_org: :width 800
#+attr_latex: :width 250px
[[file:img/lecc04/Roots-MA2pn.png]]



#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Sim-MA2pn.png :results none
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/Sim-MA2pn.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/Sim-MA2pn.png]]

*** MA(2) con un par de raíces complejas
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . notes)))
   :END:

# MA2 rojo y violeta

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
\[
\boldsymbol{\theta}(z)=1+0.64z^2
\quad\Rightarrow\quad 
X_t=(1+0.64\mathsf{B}^2)U_t
\;\; {\color{blue}{(\text{par de raices complejas})}}
\]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACF-MA2np.png :exports code :results silent
ar_params = [1,]
ma_params = [1, 0, 0.64]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, sigma2=1, lags=20)
fig.savefig('./img/lecc04/ACF-MA2np.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACF-MA2np.png]]


#+name: raices-ma2np
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Roots-MA2np.png :results silent :exports results
dfi.export(polynomial_roots_table(ma_params),
           "./img/lecc04/Roots-MA2np.png", dpi=300, table_conversion="matplotlib")
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+attr_html: :width 500px
#+attr_org: :width 800
#+attr_latex: :width 250px
[[file:img/lecc04/Roots-MA2np.png]]



#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Sim-MA2np.png :results none
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/Sim-MA2np.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/Sim-MA2np.png]]

*** MA(2) con dos raíces reales y negativas
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . notes)))
   :END:

# MA2 rojo

#+attr_ipynb: (slideshow . ((slide_type . subslide)))
\[
\boldsymbol{\theta}(z)=1+1.6z+0.64z^2
\quad\Rightarrow\quad 
X_t=(1+1.6\mathsf{B}+0.64\mathsf{B}^2)U_t
\;\; {\color{blue}{(\text{r. reales: -, -})}}
\]


#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACF-MA2rojo.png :exports code :results silent
ar_params = [1,]
ma_params = [1, 1.6, 0.64]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, sigma2=1, lags=20)
fig.savefig('./img/lecc04/ACF-MA2rojo.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACF-MA2rojo.png]]


#+name: raices-ma2rojo
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Roots-MA2rojo.png :results silent :exports results
dfi.export(polynomial_roots_table(ma_params),
           "./img/lecc04/Roots-MA2rojo.png", dpi=300, table_conversion="matplotlib")
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+attr_html: :width 500px
#+attr_org: :width 800
#+attr_latex: :width 250px
[[file:img/lecc04/Roots-MA2rojo.png]]



#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Sim-MA2rojo.png :results none
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/Sim-MA2rojo.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/Sim-MA2rojo.png]]

*** MA(2) con dos raíces reales y positivas
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . notes)))
   :END:

# MA2 violeta


#+attr_ipynb: (slideshow . ((slide_type . subslide)))
\[
\boldsymbol{\theta}(z)=1-1.6z+0.64z^2
\quad\Rightarrow\quad 
X_t=(1-1.6\mathsf{B}+0.64\mathsf{B}^2)U_t
\;\; {\color{blue}{(\text{r. reales: +, +})}}
\]

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file ACF-MA2violeta.png :exports code :results silent
ar_params = [1,]
ma_params = [1, -1.6, 0.64]
fig = plot_arma_parametric_diagnostics(ar_params, ma_params, sigma2=1, lags=20)
fig.savefig('./img/lecc04/ACF-MA2violeta.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/ACF-MA2violeta.png]]



#+name: raices-ma2violeta
#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Roots-MA2violeta.png :results silent :exports results
dfi.export(polynomial_roots_table(ma_params),
           "./img/lecc04/Roots-MA2violeta.png", dpi=300, table_conversion="matplotlib")
#+END_SRC

#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+attr_html: :width 500px
#+attr_org: :width 800
#+attr_latex: :width 250px
[[file:img/lecc04/Roots-MA2violeta.png]]



#+attr_ipynb: (slideshow . ((slide_type . skip)))
#+BEGIN_SRC jupyter-python :results file :output-dir ./img/lecc04/ :file Sim-MA2violeta.png :results none
fig = plot_arma_analysis(ar_params, ma_params, seed=2026)
fig.savefig('./img/lecc04/Sim-MA2violeta.png', dpi=300, bbox_inches='tight')
#+END_SRC


#+attr_org: :width 800
#+attr_html: :width 900px
#+attr_latex: :width 425px
[[./img/lecc04/Sim-MA2violeta.png]]


* (Resumen) características de procesos MA($q$)
   :PROPERTIES:
   :metadata: (slideshow . ((slide_type . slide)))
   :END:

#+latex: \noindent
_Siempre estacionario._

#+latex: \noindent
Para ser invertible raíces $\boldsymbol{\theta}$ fuera del círculo
unidad
$(\boldsymbol{\theta}^{-\triangleright}=\boldsymbol{\theta}^{-1}\in\ell^1)$
#+latex: \bigskip

*Tipos de representación del proceso*

#+latex: \noindent
- Como suma ponderada finita :: MA($q$) (número finito de parámetros)
  $$\boldsymbol{X}=\boldsymbol{\theta}*\boldsymbol{U}
  \quad\Rightarrow\quad X_t=\boldsymbol{\theta}(\mathsf{B})U_t$$
- Como suma ponderada infinita :: AR($\infty$) (_solo existe si es invertible_):
  $$\frac{1}{\boldsymbol{\theta}}*\boldsymbol{X}=\boldsymbol{U}
  \quad\Rightarrow\quad
  \frac{1}{\boldsymbol{\theta}}(\mathsf{B})X_t=U_t$$
#+latex: \bigskip

#+latex: {\bf Comportamiento de las funciones asociadas a los segundos momentos}
#+latex: \medskip

#+latex: \noindent
*ACF ($\boldsymbol{\rho}$):* Grado ($q$) y cogrado ($-q$)
#+latex: \smallskip

#+latex: \noindent
*PACF ($\boldsymbol{\pi}$):* Grado ($\infty$) y cogrado ($-\infty$):
@@latex:Combinación de @@ exponenciales y/o sinusoidales amortiguadas.
#+latex: \smallskip

#+latex: \noindent
*Densidad espectral* Suma de $q$ cosenos más una constante.
# proporcional al inverso de la densidad espectral de $\;\boldsymbol{\theta}*\boldsymbol{X}=\boldsymbol{U}$



* COMMENT ipynb y slides                                           :noexport:
:PROPERTIES:
:ID:       a0af0049-d6c4-4572-bb3d-e2a35b541595
:END:

#+BEGIN_SRC emacs-lisp :results silent
(require 'ox-ipynb)
(ox-ipynb-export-org-file-to-ipynb-file "Lecc04.org")
#+END_SRC

#+BEGIN_SRC sh :results silent :eval yes
jupyter nbconvert --execute --inplace Lecc04.ipynb
#+END_SRC

#+BEGIN_SRC sh :results silent :eval yes
jupyter nbconvert --config ../mycfg-GitHubPages.py --to slides --reveal-prefix "https://unpkg.com/reveal.js@5.2.1" --execute Lecc04.ipynb
#+END_SRC

